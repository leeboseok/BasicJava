//변수 : 데이터를 담을 수 있는 상자
		//변수상자에는 데이터를 바꿔담을 수 있다.
		//변수상자 내부에는 하나의 데이터만 들어갈 수 있다.
		//변수상자의 이름이 중요한데, 중복되는 이름은 사용할 수 없다.

		//변수 제작법
		//타입 이름;

//변수 작명규칙
		//1. 변수의 이름은 숫자로 시작할 수 없다. 중간이나 끝에는 가능.
		//2. 이름에는 띄어쓰기를 사용할 수 없다. 한개의 단어
		//3. 특수문자는 $_ 두가지만 이름에 사용할 수 있다.
		//4. 사용중인 이름은 중복으로 사용할 수 없다.*
		//5. 대문자와 소문자를 엄격히 구분한다.

//작명 권장사항
		//1. 파스칼표기법 : 모든 단어의 첫문자를 대문자로 표기
		//               JavaHtmlCss, 클래스명 표기시 사용
		//2. 카멜표기법 : 두번째 단어부터 첫문자를 대문자로 표기
		//              javaHtmlCss, 동작(메서드)이름표기시 사용
		//3. 팟홀표기법 : 띄어쓰기 대신 _를 사용
		//				java_html_css, 변수이름 표기시 사용


//boolean : 불리언, 부울대수
		//참(true) 또는 거짓(false)만 들어갈 수 있는 규격
		//조건의 판별을 진행할 때 많이 사용한다.

//byte : 바이트
			//아주 작은 수를 저장할 수 있는 규격 -128~127
			//통상적인 프로그램 제작에는 사용할 수 없다.
			//바이트는 잘 쓰지 않아요
			
//short : 숏
			//작은 수를 저장할 수 있는 규격 -32768~32767
			//숏도 잘 쓰지 않아요

//char : 캐릭터
		//문자 하나를 저장할 수 있는 규격
		//문자 하나를 쓸 때는 앞뒤에 '를 붙인다 '가'
		//캐릭터 타입에는 ""데이터를 넣을 수 없다.
		//''내부에는 여러개의 문자가 들어갈 수 없다.
		//불편해서 잘 사용하지 않는다.

//float : 플로트
		//짧은 소수점을 표기할 수 있는 규격
		//통상적으로 소수점이하 7자리까지 포함가능
		//짧은 소수점을 표현할때는 f를 붙여서 표기한다.

//double : 더블
		//긴 소수점을 표기할 수 있는 규격
		//*X5,000,000 일단 소수점을 적으면 double로 본다.
		//통상적으로 소수점이하 15자리까지 포함가능
		//double은 d를 붙여도 되고 안붙여도 된다.

//int : integer
		//일상적으로 사용하는 수가 들어갈 수 있는 규격
		//-2,147,483,648 ~ 2,147,483,647
		#####//★5,000,000 가장 많이 사용
		#####//★5,000,000 java에 숫자를 적으면 일단 int로 본다.

//long : 롱
		//아주 큰 수를 저장할 수 있는 규격
		//기본 자료형중 가장 큰 수를 저장할 수 있는 규격
		//-9223372036854775808 ~ 9223372036854775807
		
		//int의 범위를 벗어나는 크기의 수는 뒤에 l, L 붙여서 표기
		
//String : 스트링
		//여러개의 문자(문자열)를 저장할 수 있는 규격
		//누가 설계도를 통해 만들어준 타입
		//*5,000,000 모르면 개발 불가
		//여러개의 문자는 ""로 묶어주어야 한다. "가나다"


#####/ 블락 내부에서 생성된 변수는 블락이 종료되면 소멸한다.

//작명 권장사항(이름에 띄어쓰기를 사용하지 못하기 때문에 권장)
		//1. 파스칼표기 : 단어의 첫 문자를 대문자로 표기, class명에 사용
		//2. 카멜표기 : 두번째 단어부터 첫 문자를 대문자로 표기, 동작이름에 사용
		//3. 팟홀표기 : 띄어쓰기 대신 _를 사용, 변수명에 사용
		//지키지 않아도 오류가 발생하지는 않는다. 
		
		// {} 블락 : 영역을 나누는 기호

//이항연산자
		//	산술연산자 : 계산의 결과가 특정한 값으로 나온다
		//	비교연산자 : 계산의 결과가 true 또는 false로 나온다.
		// 	> : 왼쪽이 오른쪽보다 큰지 확인
		//	< : 왼쪽이 오른쪽보다 작은지 확인
		//	>=: 왼쪽이 오른쪽보다 크거나 같은지 확인
		//	<=: 왼쪽이 오른쪽보다 작거나 같은지 확인
		//	==: 왼쪽과 오른쪽이 동일한지 확인, 조건작성시 =로 쓰지 않도록 주의 *x5,000,000
		//	!=: 왼쪽과 오른쪽이 다른지 확인

//논리 연산자 :true, false를 가지고 true, false를 계산하는 연산자
		#####// 한개만 적으면 전혀 다른 연산자이니 주의 *x5,000,000
		// && : ~이고 ~이다, 앞과 뒤의 조건이 모두 true인 경우만 true
		// || : ~이거나 ~이다, 앞과 뒤의 조건 중 하나라도 true인 경우 true


//비트연산자 : 계산의 결과가 특정 값을 보이도록 연산
		//얘는 모르셔도 개발하는데 아무 지장이 없습니다.
		//수를 이진수로 변환하여 자릿수별로 계산
		// & : 자릿수가 모두 1이면 1 하나라도 0이면 0
		// | : 자릿수중 하나라도 1이면 1, 모두 0이면 0
		// ^ : xor(exclusive or), 자릿수가 서로 다르면 1, 같으면 0

//시프트 연산자
		//이진수로 변환해서 자릿수를 변화시키는 방법
		// A<<B : A를 이진수 변환해서 왼쪽으로 B칸 자릿수 증가
		// A>>B : A를 이진수 변환해서 오른쪽으로 B칸 자릿수 감소
//삼항연산자
		//	A?B:C;	A가 참이면 B수행, A가 거짓이면 C수행
		//	조건에 따라 실행할 부분을 결정하는 연산자
		//	기능은 반드시 필요하지만 소스코드 읽기가 힘들어서 잘 사용하지 않는다.

//단항연산자
		//	부정연산자 ! : 값을 반전시키는 용도로 사용
		//	증감연산자 ++, -- : 값을 한단위 증가시키거나 감소시킬 때 사용
		
		//증감연산자는 전위증감이냐 후위증감이냐에 따라 계산 우선순위에 차이가 있다.
		//상수는 변수제작과 동일하지만 앞에 final이 붙는다.
		//상수는 연산이 불가
		final int a=15; //앞에 final 붙이면 상수
		//a++; 값을 바꿀 수 없어서 증감 불가

//이항연산자
		//	산술연산자 : +, -, *, /, %
		//	계산의 결과가 특정한 값으로 표현된다.

//변수 var(variable)

//boolean : 불리언  //논리학 학자 //흑백논리 //참과 거짓
		//true(참) 또는 false(거짓)만 저장할 수 있는 작은 변수타입

//char : 케릭터, 문자 하나를 저장할 수 있는 변수타입
		//저장하는 문자가 명령어가 아닌 문자 하나임을 알려주기 위해 'A'로 데이터를 표현
		//컴퓨터는 문자 자체의 의미를 해석할 수 없기 때문에 문자마다 숫자를 부여해서 기억
		//문자 하나는 ''(홑따옴표), 여러개의 문자는 ""(쌍따옴표)로 묶어줘야 한다.

//부동소수점을 표현할 때 사용하는 타입 //공중에 떠서 다니는 소숫점 //정밀한 데이터를 위하여
		//float : 짧은 소수점을 표현할 때 사용하는 타입
		//double : 긴 소수점을 표현할 때 사용하는 타입 *x5,000,000

//byte : 바이트, 아주 작은 수가 저장될 수 있는 타입

//short : 숏, 작은 수가 저장될 수 있는 타입

#####//int : 인티저, 일상적인 수가 저장될 수 있는 타입 *x5,000,000

//long : 롱, 아주 큰 수가 저장될 수 있는 타입

//매서드 : 설계도에 작성되어 객체가 수행하는 동작
		//리턴타입 동작명(){수행할 동작;}
		//리턴타입이 void가 아닌 모든 동작은 return 뒤에 해당 데이터를 적어서 특정해줘야 한다.

#####//if : 이프문, 조건문 : 조건의 true, false 여부에 따라 실행을 결정하는 제어문
		//if(조건){ 조건이 true일 경우 수행할 문장;}
		//if문에 {}을 지정하지 않으면 ()뒤로 나오는 첫번째 ;까지를 자기의 {}범위로 본다.

//if-else문
		//if문은 실행 할지 말지를 결정한다면
		//if-else문은 둘 중 하나를 골라서 실행하게 된다.
		//둘 다 실행되는 경우는 없고, 둘다 실행되지 않는 경우도 없다.
		//if(조건){조건이 true일때 실행될 부분;}else{조건이 false일때 실행될 부분;}

//switch문 : 변수의 값에 따라 실행위치를 결정하는 제어문
		//switch(변수이름){case 값:실행할문장;}
		//시작지점을 설정하는 것. //그 위치로 점프
		//switch문은 실행위치만 결정하지 선별기능이 없으므로 아래로 쭉 읽어 내려가지만
		//break를 이용하여 유사선별기능을 구현할 수 있다.

//클래스 : 객체를 조립하는 설계도
		//*5,000,000
		//클래스는 필드, 메서드, 생성자를 가질 수 있다.
		//1. 필드 : 객체간 구별을 위한 데이터(속성)를 저장할 수 있는 공간
		//2. 메서드 : 객체가 수행할 수 있는 동작
		//3. 생성자 : 객체를 조립하는 방법
		//클래스는 객체로 조립하여서 사용해야 한다. 
		//객체 조립방법 : new 클래스이름();
		//조립된 객체는 변수에 담아야 사용하기 편하다.
		
		//클래스 하나로 객체는 여러개 제작할 수 있고
		//제작된 객체는 서로 영향을 받지 않는다.
		//class제작법 : 같은 패키지 내부에서는 한번 사용한 클래스명을 다시 사용하지 않도록 주의
		//class 이름{}
		//클래스는 다른 클래스 내부에 만들어도 되고 밖에 만들어도 되지만
		//클래스를 다른 클래스 내부에 만들면 처음에 공부하기 어려워진다.
		//필드 : 통상적으로는 변수로 제작한다.
		//객체가 가질 수 있는 다른 객체와 구별되는 데이터(속성attribute)를 저장할 공간.

#####//클래스는 설계도다
		//클래스는 필드, 메서드, 생성자를 가질 수 있다.
		//필드는 클래스 내부에 작성되어 조립된 객체가 가지는 속성을 저장할 수 있는 공간

#####//메서드 : 클래스 내부에 작성되어 객체가 수행하는 동작 *X5,000,000 ///Verfahren : 수법, 방식, 행동, 취급, 처리, 처치
		//	반드시 미리 클래스 내부에 작성되어 있어야 동작이 가능하다.
		// 	제어문들은 메서드 내부에 작성되어 있어야 동작이 가능하다.
		//	리턴타입 동작이름(){동작호출시 수행할 문장};
		//	리턴타입 : 동작을 실행한 이후에 돌려주는 데이터의 형태
		// 	 	- 리턴타입이 void인 경우 : 동작의 실행결과 아무것도 반환하지 않는 경우
		//		- 리턴타입이 void가 아닌 경우 : 동작의 실행결과 리턴타입에 해당하는 데이터를 반환하는 경우
		// 		==제작시 return 뒤에 반환할 데이터를 특정해서 알려줘야 한다.
		//		==리턴타입과 리턴되는 데이터의 타입과 해당 데이터를 저장할 변수의 타입이 일치해야 한다.
		//		==리턴되는 값을 반드시 사용해야 하는건 아니다
		//		==리턴이 이루어지면 그 이후로는 다른 명령을 시킬 수 없다. return이 실행되면 그 이후로는 다른 명령 불가
		
		//class를 이용하려면 먼저 객체를 만들어야 한다.
		//메서드는 반드시 객체를 통해서 시켜야 한다.
		//클래스 : 클래스는 필드, 메서드, 생성자를 가질 수 있다.
		//메서드 : 클래스 내부에 작성되어 객체가 수행하는 동작

//매개변수 : 메서드를 실행할 때 데이터를 주고 시켜야 하는 경우
		//		해당 데이터를 메서드 내부의 변수를 통해 전달해 주어야 한다.
		//		메서드 외부에서 데이터를 메서드 내부로 전달 할 경우 매개변수를 사용한다.
		//		매개변수의 타입과 일치하는 데이터를 주지 않으면 동작을 시킬 수 없다.
		//		매개변수는 메서드 내부에서 변수처럼 이용가능하다.
		//리턴타입 이름(매개변수){실행 시 수행할 문장;}
		//리턴타입과 이름이 똑같은 메서드를 매개변수의 수와 종류를 다르게 해서
		//다른 메서드처럼 사용하는 방법
		#####//"메서드 오버로드" *X5,000,000

//메서드 : 클래스 내부에 작성되어 객체가 수행하는 동작 *x5,000,000
		//같은 이름을 가진 동작이 여러개이면 오류의 원인이 된다.
		//메서드 오버로드 : 매개변수에 차이를 두어 같은 이름을 가진 동작을 여러개 사용하는 방법
		//매개변수의 명칭으로는 오버로드가 성립하지 않는다, 타입과 수에 영향을 받는다.

//Object Oriented : 객체지향

class Car{
	//클래스는 필드(Field), 메서드(Method), 생성자(Constructor)를 가질 수 있다.
	//필드 : 객체가 데이터를 저장하는 공간, 통상적으로 변수로 만들어지고, 속성을 저장한다. 
	//속성(attribute)사물의 성질, 특징. 실체의 본질적인 성질. 그것이 없다면 실체를 생각할 수 없는 것.
	int number;
	//메서드 : 객체가 수행할 수 있는 동작, 호출이 이루어질 때 수행됨
		//리턴타입 : 동작수행시 반환하는 값, void는 없고 나머지는 return뒤에 특정해줘야함
		//매개변수 : 동작을 시킬때 줘야되는 값을 담을 변수, 
	void run(int a) {
		System.out.println(number+"번 차량이 주행합니다.");
	}
	//생성자 : 객체를 조립하는 동작
		//객체가 조립될 때 반드시 단 한번 수행된다. *x5,000,000
		//리턴타입이 적혀있지 않고 이름이 클래스와 똑같은 메서드처럼 생겼다.
		//따로 작성하지 않아도 자동으로 보이지 않게 제작되어 있음
		//다른 동작을 수행하고자 한다면 한번 적어서 내용을 넣어줘야함.
		//객체를 만들때는 생성자 중 하나만 선택해서 조립하게 된다.
	Car(){
		//필드의 내용을 변경하는 등 특정한 동작을 하기 위해서는 한번 적어줄 필요가 있다.
		number=1234;
	}
	//생성자 오버로드 *x5,000,000
	//메서드는 이름바꿔서 쓰면 되지만 생성자는 이름을 바꿀 수가 없다.
	Car(int a){
		number=a;
	}
}

//접근제한자 : 소스코드의 위치를 기준으로 해당 데이터에 접근여부를 결정하는 단어
	private int pri;	//해당 클래스 내부에서만 사용가능
	protected int pro;	//같은 패키지 또는 상속관계에서 사용가능
	int def;			//같은 패키지에서만 사용가능
	public int pub;		//전체공개

Data d=new Data();
		//d.pri=10; private은 같은 클래스 내부에서만 사용가능한데 Sample2는 다른 클래스임
		d.pro=20; //Data클래스와 Sample2클래스가 같은 패키지 내부에 있기 때문에 사용가능
		d.def=30; //Data클래스와 Sample2클래스가 같은 패키지 내부에 있기 때문에 사용가능
		d.pub=40; //public은 전체공개임으로 당연히 사용가능
		System.out.println();
Data d=new Data();
		//d.pri=10; private은 클래스를 벗어나면 사용할 수 없다.
		//d.pro=20; protected는 패키지를 벗어나면 사용할 수 없다.
		//d.def=30; default(아무것도 안적은거)는 패키지를 벗어나면 사용할 수 없다.
		d.pub=40;	//public은 패키지를 벗어나도 사용할 수 있다.
		System.out.println(d.pub);

//객체를 만들때는 생성자 중 하나만 선택해서 조립하게 된다.
//오버라이드 : 기존에 있던 기능을 재정의해서 사용하는 기법
	//클래스 내부에 toString()을 재정의하면 객체를 출력시 주소가 아니라 해당 내용을 출력한다.

//클래스(설계도)
//클래스는 필드, 메서드, 생성자를 가질 수 있다.

//필드 : 변수, 생성된 객체가 구별되기위한 데이터를 저장하는 장소
//메서드 : 동작, 생성된 객체가 수행할 수 있는 동작
	#####//리턴타입 이름(매개변수제작){수행할 동작; return value;} *X5,000,000 //리턴타입이 void가 아닌경우는 return을 넣어준다.
	//매개변수는 메서드 내부에서 변수처럼 사용이 가능하다.
	//매개변수가 있는 메서드는 반드시 해당 변수 타입에 맞는 데이터를 순서대로 주어야 실행 가능하다.
	//if문이나 for문같은 제어문들은 메서드 내부에 작성해야 한다.
//생성자 : 객체를 조립하는 방법, 객체를 생성해주는 기능
		//별도로 제작하지 않아도 기본적으로 들어가 있는 기능
		//개발자가 본인의 의도를 담아 제작법을 만들려 하는 겨우 별도로 제작해 주어야 한다.
		//클래스이름(){추가적으로 실행할 내용;}
		//리턴타입이 적혀있지 않은 클래스와 이름이 똑같은 메서드처럼 생겼다.
		//생성자의 용도 : 필드에 초기 데이터를 입력하거나 객체를 다른 형태로 조립할 때 사용
		#####//무조건 단 한번 객체가 조립될 때 실행된다. *X5,000,000
		//클래스랑 이름이 똑같다. //동작

//데이터 출력을 편하게 해주는 toString 오버라이드

//오버라이드는 상속에서 굉장히 중요한 역할을 한다.

//상속 : 클래스간에 부모클래스로부터 내용들을 자식클래스가 이어받는 문법
	//자바에는 다중상속이 금지되어 있다.
	//자식은 여럿이 존재할 수 있지만 한 클래스는 하나의 부모만 가질 수 있다.
	//자식클래스이름 extends 부모클래스이름 : 상속이 성립한다.
	//상속이 성립하면 부모클래스가 가진 필드와 메서드를 이어 받는다.
	//자식은 부모가 가진 필드와 메서드를 이용할 수 있지만, 부모는 자식의 구성물을 이용할 수 없다.
	//자식객체는 부모가 들어갈 수 있는 변수에 들어갈 수 있지만
	//부모객체는 자식이 들어갈 수 있는 변수에 들어갈 수 없다.
//오버라이드 : 부모로부터 물려받은 메서드를 자식이 재정의하여 사용하는 방법
	//부모의 메서드랑 똑같은걸 적은 뒤에 내용만 바꾼다.
	//오버라이드시 부모의 기능을 유지하고 싶다면 super.메서드();로 실행
	void work() {
		super.work();
		System.out.println("저는 건성건성 할껍니다.");
	}
	//자식이 객체가 되기 위해서는 부모의 조립된 모양이 필요하니
	//자식의 생성자를 호출하면 부모의 생성자가 먼저 실행된다.
	//부모의 생성자가 여러개라 그 중 하나를 골라야 하는 경우 super()를 이용한다.
	//부모의 생성자는 자식생성자보다 늘 먼저 실행되어야 하므로
	//자식 생성자의 가장 위에서 부모의 생성자를 골라야한다.

//배열 : 여러개의 데이터를 index로 구분하여 하나의 변수에 저장하는 기법
		//배열이 생성되면 내부 데이터의 수를 length라는 변수에 저장한다.
		//객체타입의 배열을 제작하는 경우 위 코드는 단순히 칸만 나누어 둔다
//배열 내부의 모든 데이터를 순서대로 읽는 for문 /암기
		for(int i=0; i<arr.length; i++) {
			System.out.println(arr[i]);
		}


//상속
//부모 클래스가 가진 필드, 메서드를 이어받아 사용하는 방법
//부모 클래스에 작성된 내용들은 자식 클래스가 사용할 수 있지만
//자식 클래스에 별도로 작성된 내용들은 부모 클래스가 사용할 수 없다.

//부모 크기의 변수에는 자식클래스로 만들어진 객체가 들어갈 수 있고, 이는 더 위 조상에게도 해당한다.
//extends를 적지 않은 모든 클래스는 Object클래스의 상속을 받는다.
//따라서 보든 클래스의 조상은 object이며 대부분의 데이터를 저장할 수 있는 규격
//자식클래스를 객체로 조립하면 부모의 생성자가 '먼저'실행된다.

//오버라이드 : 부모에게서 '상속받은 메서드'를 자식이 재정의하여 사용하는 기법

JAVA SQL
//데이터베이스 연결

package conn;

import java.sql.*; //sql을 이용할 때 필요한 데이터 규격들이 들어 있어요

public class Sample1 {
	public static void main(String[] args) {
		//jdbc가 있어야 데이터베이스와 통신이 가능하다.
		Connection conn;	//접속회선
		Statement stmt;		//쿼리문을 전송하기 위한 규격
		ResultSet rs;		//select문의 결과를 받아오기 위한 규격
		
		String url="jdbc:mysql://127.0.0.1:3306/sample";	//접속위치
		String db_id="root";								//접속아이디
		String db_pw="iotiot";								//접속 비번
		String sql="select * from student order by sum desc";
		try {
			conn=DriverManager.getConnection(url, db_id, db_pw);	//회선가져옴
			stmt=conn.createStatement();
			rs=stmt.executeQuery(sql);
			System.out.println("번호"+"\t"+"이름"+"\t"+"국어"+"\t"+"수학"+"\t"+"영어"+"\t"+"총점"+"\n");
			while(rs.next()) {
				String num=rs.getString(1);
				String name=rs.getString(2);
				String kor=rs.getString(3);
				String math=rs.getString(4);
				String eng=rs.getString(5);
				String Sum=rs.getString(6);
				System.out.println(num+"\t"+name+"\t"+kor+"\t"+math+"\t"+eng+"\t"+Sum);
			}
		}catch(Exception e) {
			System.out.println("접속중 오류발생 : "+e);
		}
	}
}

//JDBC : 자바 데이터베이스 커넥터를 통해 자바와 데이터베이스가 연결된다 (파이프)
//배관이라고 생각하자
//배관 설치, 회수

//회수하는 코드
package close;

import java.sql.*;	//Connection, Statement, ResultSet
public class Sample {
	public static void main(String[] args) {
		Connection conn=null;
		Statement stmt=null;
		ResultSet rs=null;
		
		String url="jdbc:mysql://127.0.0.1:3306/sample";
		String db_id="root";
		String db_pw="iotiot";
		String sql="select*from student;";
		try {
			//회선연결처리 부분
			conn=DriverManager.getConnection(url, db_id, db_pw);
			stmt=conn.createStatement();
			System.out.println("<h1>접속을 환영합니다.</h1>");
		}catch(Exception e) {
			System.out.println("접속 중 오류발생 : "+e);
		}finally {
			//회선 종료처리 try-catch안에 제작해야함.
			try {
				//회선종료처리 부분
				if(rs!=null)rs.close();
				if(stmt!=null)stmt.close();
				if(conn!=null)conn.close();
			}catch(Exception ex) {
				System.out.println("접속 해제 중 오류발생 : " + ex);
			}//end of catch
		}//end of finally
	}//end of main
}//end of class

//자료구조

	//List 중복 o 순서 엄격 //배열의 성질을 갖고 있다. Array List
	//Set 중복 x 순서 x //종류를 확인하고 싶을 때 유용하다.
	//Map 데이터 중복 o, 검색어 중복 x, 순서 상관 x (검색어 : 데이터) 
	//속도 가장빠른 hash Set //Tree Set // hash Map

//컬렉션 - Study29_Sample1

		//자료구조를 이용할 수 있도록 구현된 일종의 프레임워크 -> 사용방법이 딱 정해져 있다.
		//자버 컬렉션은 interface로 구성되어 있어 바로 객체로 조립하여 사용할 수는 없다.
		
		//자바 컬렉션의 종류
		//List : 순서가 엄격히 존재하는 자료형, index가 검색 기준이자 순서
		//		Vector, Stack, LinkedList, *ArrayList 등이 있음
		//Set : 순서가 존재하지 않는 자료형, 자료의 구별이 불가능하기 때문에 중복데이터를 허락하지 않는다.
		//		*HashSet, SortedSet, TreeSet 등이 있음
		//Map : 검색어와 데이터가 한 쌍으로 이루어진 자료형, 데이터는 중복이 가능하지만 검색어는 중복이 불가
		//		*HashMap, SortedMap, TreeMap 등이 있음.
		
		//HashSet 데이터를 짧은 순으로 정렬해 놓는다.
		//읽어 내는 속도를 빠르게 하지만
		//순서가 엉키어 버리고
		//뒤에 오는 데이터는 시간이 조금 손해가 있다.

		List L=new ArrayList(); //컬렉션은 interface라서 컬렉션이 구현된 클래스를 이용해서 객체를 만들어야 한다.
		//List.add(자료) : 해당 자료를 리스트에 추가함. 가장 마지막 번호에 추가됨
		//List.add(index, 자료) : 해당 index에 자료를 추가함. 뒤 자료부터는 하나씩 index가 밀림
		//List.get(index) : index에 해당하는 자료를 확인
		L.add(1);
		L.add(2);
		L.add(3);
		L.add(3); // 중복이 허용된다.
		L.add("A"); // 문자도 들어간다 //기본타입은 다 들어간다. //매개변수 타입이 오브젝트 타입이라 모든 타입이 들어간다
					//다만 나올때 자신의 정보를 잃는다. //그래서 역캐스팅을 해줘야 한다.
		L.add(2, "B");
		//ArrayList는 중간에 데이터를 넣는 기능이 있다.
		
		System.out.println(L);
		System.out.println(L.size()); 
		//Array 에는 .length, List 에는 .size()가 쓰인다.
		//List는 배열과 달리 size()메서드로 크기를 확인해야 한다. .length를 사용할 수 없다. *X5,000,000
		System.out.println(L.get(4));


		//ArrayList.addAll(ArrayList); : add()처럼 값을 넣는데 리스트가 하나 통짜로 들어간다.
		//ArrayList.addAll(index, ArrayList); : 해당 위치에 리스트 하나를 통짜로 집어넣는다.

package collection;

import java.util.*;

public class Sample4 {
	public static void main(String[] args) {
		List<String> L=new ArrayList<String>();
		L.add("공주는 잠 못 이루고");
		L.add("JAVA");
		L.add("HTML");
		L.add("CSS");
		L.add("SQL");
		L.add("JSP");
		
		L.add(4, "JAVASCRIPT");
		System.out.println(L);
		//List.subList(start, end) 해당 index범위 내의 내용물을 별도의 리스트로 추출
		//마지막 숫자는 포함되지 않는다.(커서의 위치를 기준으로 하기 때문이다.)
		List<String> sub=new ArrayList<String>();
		sub=L.subList(2, 5);
		System.out.println(sub);
		
		//List.remove(index); 해당 위치의 자료를 제거
		//List.remove(value); 해당 값을 가진 자료를 제거
		L.add(0, "CSS");
		System.out.println(L);
		
		L.remove(1);
		L.remove("CSS");
		System.out.println(L);
		
		//Collections.sort(L); //오름차순 정렬
		Collections.sort(L, Collections.reverseOrder()); //내림차순 정렬
		System.out.println(L);
	}
}



//제네릭 - Study29_Sample3

package generic;

public class Sample3 {
	public static void main(String[] args) {
		//제네릭 : 클래스의 특정 문자를 원하는 타입으로 변환하는 기법
		//자료형을 마음대로 조절할 수 있어서 편리하다
		Normal n=new Normal("스트링");
		String result=n.show();
		System.out.println(result);
		//n.a=15;	객체를 사용하는 입장에서는 class의 수정 없이 타입을 변경할 수 없다.
		Gene<Float> g=new Gene<Float>(5+3.0f);// 참조형, 기본형 다됨.
		//<>꺽쇄 안에 첫글자 대문자로 들어감 참조형, 기본형(String, Integer, Boolean, Long, Double, Byte, Char, float)
		Float result2=g.show();
		System.out.println(result2);
	}
}
class Normal{
	String a;
	Normal(String b){
		a=b;
	}
	String show() {
		return a;
	}
}
class Gene<T>{
	T a;
	Gene(T b){
		a=b;
	}
	T show() {
		return a;
	}
}